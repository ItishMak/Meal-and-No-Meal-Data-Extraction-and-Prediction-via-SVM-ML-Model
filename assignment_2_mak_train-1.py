# -*- coding: utf-8 -*-
"""Assignment_2__Mak_train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UG40rNLITDj1CwSa2tocWXF87bkrFDPD
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from past.builtins import xrange
import datetime
from datetime import timedelta
from pandas import DataFrame
from scipy.fftpack import fft, ifft,dct
import pywt
import scipy.stats as stats
from sklearn.metrics import classification_report, accuracy_score, make_scorer

import warnings
warnings.filterwarnings("ignore")

insulin_data1=pd.read_csv('InsulinData.csv',low_memory=False, parse_dates = [['Date', 'Time']])[['Date_Time', 'BWZ Carb Input (grams)']]
cgm_data1=pd.read_csv('CGMData.csv',low_memory=False,parse_dates = [['Date', 'Time']])

insulin_data2=pd.read_excel('InsulinAndMealIntake670GPatient3.xlsx', parse_dates = [['Date', 'Time']])[['Date_Time', 'BWZ Carb Input (grams)']]
cgm_data2=pd.read_excel('CGMData670GPatient3.xlsx',parse_dates = [['Date', 'Time']])

def trimData(insulin_data, cgm_data):
    min_insulin_time = min(insulin_data['Date_Time'])
    min_cgm_time = min(cgm_data['Date_Time'])
    min_timestamp = max(min_insulin_time, min_cgm_time)
    max_insulin_time = max(insulin_data['Date_Time'])
    max_cgm_time = max(cgm_data['Date_Time'])
    max_timestamp = min(max_insulin_time, max_cgm_time)
    insulin_trimmed = insulin_data[(insulin_data['Date_Time'] >= min_timestamp)]
    insulin_trimmed = insulin_trimmed.reset_index(drop=True)
    insulin_trimmed = insulin_data[(insulin_data['Date_Time'] <= max_timestamp)]
    insulin_trimmed = insulin_trimmed.reset_index(drop=True)
    cgm_trimmed = cgm_data[(cgm_data['Date_Time'] >= min_timestamp)]
    cgm_trimmed = cgm_trimmed.reset_index(drop=True)
    cgm_trimmed = cgm_data[(cgm_data['Date_Time'] <= max_timestamp)]
    cgm_trimmed = cgm_trimmed.reset_index(drop=True)
    return insulin_trimmed, cgm_trimmed

insulin_data1_trimmed, cgm_data1_trimmed = trimData(insulin_data1, cgm_data1)
insulin_data2_trimmed, cgm_data2_trimmed = trimData(insulin_data2, cgm_data2)

Bool_carbinput_data1=pd.notnull(insulin_data1_trimmed['BWZ Carb Input (grams)'])
Bool_carbinput_data2=pd.notnull(insulin_data2_trimmed['BWZ Carb Input (grams)'])
insuline_data_ext1=insulin_data1_trimmed[Bool_carbinput_data1]
insuline_data_ext2=insulin_data2_trimmed[Bool_carbinput_data2]
insuline_data_ext1 = insuline_data_ext1[insuline_data_ext1['BWZ Carb Input (grams)'] != 0].sort_values(by=['Date_Time'], ignore_index = True)
insuline_data_ext1 = insuline_data_ext1.reset_index(drop=True)
insuline_data_ext2 = insuline_data_ext2[insuline_data_ext2['BWZ Carb Input (grams)'] != 0].sort_values(by=['Date_Time'], ignore_index = True)
insuline_data_ext2 = insuline_data_ext2.reset_index(drop=True)

def extract_meal_cgm_timestamps(meal_dataframe):
    meal_data = []
    meal_len = len(meal_dataframe)-1
    for row in range(0,meal_len):
        new_time = meal_dataframe.at[row, 'Date_Time'] + timedelta(hours = 2)
        if(new_time > meal_dataframe.at[row+1, 'Date_Time']):
           continue
        else:
             meal_data.append(meal_dataframe.at[row, 'Date_Time'])
    meal_dataframe_fin = pd.DataFrame(meal_data)
    return meal_dataframe_fin

# result = []
meal_data1 = extract_meal_cgm_timestamps(insuline_data_ext1)
meal_data2 = extract_meal_cgm_timestamps(insuline_data_ext2)
print(meal_data2)

cgm_data1_trimmed['Sensor Glucose (mg/dL)'] = cgm_data1_trimmed['Sensor Glucose (mg/dL)'].interpolate(method = 'linear')
cgm_data2_trimmed['Sensor Glucose (mg/dL)'] = cgm_data2_trimmed['Sensor Glucose (mg/dL)'].interpolate(method = 'linear')

cgm_data1_trimmed = cgm_data1_trimmed[['Date_Time','Sensor Glucose (mg/dL)']]
cgm_data1_trimmed = cgm_data1_trimmed.reindex(index=cgm_data1_trimmed.index[::-1])
cgm_data1_trimmed = cgm_data1_trimmed.reset_index(drop=True)
cgm_data2_trimmed = cgm_data2_trimmed[['Date_Time','Sensor Glucose (mg/dL)']]
cgm_data2_trimmed = cgm_data2_trimmed.reindex(index=cgm_data2_trimmed.index[::-1])
cgm_data2_trimmed = cgm_data2_trimmed.reset_index(drop=True)

def extract_nomeal_cgm_timestamps(no_meal_dataframe):
    no_meal_data = []
    len_no_meal_dataframe = len(no_meal_dataframe)-1
    for row in range(len_no_meal_dataframe):
        new_time = no_meal_dataframe.loc[row, 0] + timedelta(hours = 4)
        if( new_time > no_meal_dataframe.at[row+1, 0]):
            continue
        else:
            two_hrs = timedelta(hours = 2) 
            st_time = no_meal_dataframe.at[row, 0] + two_hrs
            diff = st_time - no_meal_dataframe.at[row+1,0]
            if (diff.days>0):
                hours = int((diff.days*24*3600 + diff.seconds)//3600) 
            else:
                hours = int(diff.seconds//3600)
            for i in range(2,hours,2):
                if st_time + timedelta(hours = i) <= no_meal_dataframe.at[row+1, 0]: 
                    no_meal_data.append(st_time + timedelta(hours = i) )
                
           
    no_meal_data = pd.DataFrame(no_meal_data)
    return no_meal_data

nomeal_data1 = extract_nomeal_cgm_timestamps(meal_data1)
nomeal_data2 = extract_nomeal_cgm_timestamps(meal_data2)
print(nomeal_data2)

def meal_cgm_extraction(meal_cgm_dataframe, cgmdata):
    list1 = ['cgm_val'+str(x) for x in range(30)]
    meal_data = pd.DataFrame(columns = list1)
    for id in meal_cgm_dataframe.index:
        dict1 = dict()
        data_sets = cgmdata[cgmdata['Date_Time'] >= meal_cgm_dataframe[0][id]]
        data_set_list = list(cgmdata.loc[data_sets.index[0]-6: data_sets.index[0]+23, 'Sensor Glucose (mg/dL)'].values)
        cgm_list=[]
        for id1, cgm_val in enumerate(data_set_list):
            cgm_list.append(cgm_val)
            for cgm in cgm_list:
              dict1[list1[id1]] = cgm_val
        meal_data = meal_data.append(dict1, ignore_index = True)
    return meal_data

cgm_meal1 = meal_cgm_extraction(meal_data1, cgm_data1_trimmed)
cgm_meal2 = meal_cgm_extraction(meal_data2, cgm_data2_trimmed)
print(cgm_meal1)

def nomeal_cgm_extraction(no_meal_cgm_dataframe, cgmdata):
    list1 = ['cgm_val'+str(x) for x in range(24)]
    no_meal_data = pd.DataFrame(columns = list1)
    #print(data)
    for id in no_meal_cgm_dataframe.index:
        dict1 = dict()
        data_sets = cgmdata[cgmdata['Date_Time'] >= no_meal_cgm_dataframe[0][id]]
        #print(temp1)
        data_set_list = list(cgmdata.loc[data_sets.index[0]-0: data_sets.index[0]+23, 'Sensor Glucose (mg/dL)'].values)
        cgm_list=[]
        #print(inputs)
        for id1, cgm_val in enumerate(data_set_list):
          cgm_list.append(cgm_val)
          for cgm in cgm_list:
            dict1[list1[id1]] = cgm
        no_meal_data = no_meal_data.append(dict1, ignore_index = True)
    return no_meal_data

cgm_nomeal1 = nomeal_cgm_extraction(nomeal_data1, cgm_data1_trimmed)
cgm_nomeal2 = nomeal_cgm_extraction(nomeal_data2, cgm_data2_trimmed)
print(cgm_nomeal2)

meal_cgm_master = pd.concat([cgm_meal1,cgm_meal2]).reset_index(drop=True)
no_meal_cgm_master = pd.concat([cgm_nomeal1,cgm_nomeal2]).reset_index(drop=True)
meal_cgm_master_list = meal_cgm_master.values.tolist()
no_meal_cgm_master_list = no_meal_cgm_master.values.tolist()

meal_cgm_master

no_meal_cgm_master

def diff_max_min_cgm(meal_list,row):
  max_cgm_val = max(meal_list[row])
  min_cgm_val = min(meal_list[row])
  result = max_cgm_val - min_cgm_val
  return (result)

difference_list_meal = []
for row in range (len(meal_cgm_master_list)):
  difference = diff_max_min_cgm(meal_cgm_master_list,row)
  difference_list_meal.append(difference)
difference_df_meal = pd.DataFrame(difference_list_meal) 
difference_df_meal

difference_list_no_meal = []
for row in range (len(no_meal_cgm_master_list)):
  difference = diff_max_min_cgm(no_meal_cgm_master_list,row)
  difference_list_no_meal.append(difference)
difference_df_no_meal = pd.DataFrame(difference_list_no_meal) 
difference_df_no_meal

def coeff_of_var(meal_data,row):
  mean = np.mean(meal_data[row])
  std_dev = np.std(meal_data[row])
  result = mean/std_dev
  return (result)

coeff_of_var_meal_list = []
for row in range(len(meal_cgm_master_list)):
    coeff_val = coeff_of_var(meal_cgm_master_list,row)
    coeff_of_var_meal_list.append(coeff_val)
coeff_of_var_df_meal = pd.DataFrame(coeff_of_var_meal_list) 
coeff_of_var_df_meal 

coeff_of_var_no_meal_list = []
for row in range(len(no_meal_cgm_master_list)):
    coeff_val = coeff_of_var(no_meal_cgm_master_list,row)
    coeff_of_var_no_meal_list.append(coeff_val)
coeff_of_var_df_no_meal = pd.DataFrame(coeff_of_var_no_meal_list) 
coeff_of_var_df_no_meal

def discrete_wavelet_trans(meal_data,row):
  (cA,cD) = pywt.dwt(meal_data[row], 'db1')
  cA = cA[::-1][0:8]
  return (cA,cD)

x_meal=[]
for row in range(len(meal_cgm_master_list)):
  x1,y1 = discrete_wavelet_trans(meal_cgm_master_list,row)
  x_meal.append(list(x1))
  discrete_wavelet_df_meal = pd.DataFrame(x_meal)  
discrete_wavelet_df_meal 

x_no_meal=[]
for row in range(len(no_meal_cgm_master_list)):
  x1,y1 = discrete_wavelet_trans(no_meal_cgm_master_list,row)
  x_no_meal.append(list(x1))
  discrete_wavelet_df_no_meal = pd.DataFrame(x_no_meal)  
discrete_wavelet_df_no_meal

def windowed_mean(meal_list,row):
  w_size = 5
  window_averages =[]
  i=0
  while i < len(meal_list[row]) - w_size +1: 
    nw_size = meal_list[row][i : i + w_size]
    w_average = sum(nw_size)/w_size
    window_averages.append(w_average)
    i+=w_size
  # print(len(window_averages))
  return (window_averages[1:5]) 

windowed_average_list_meal = []
for row in range (len(meal_cgm_master_list)):
  average_list = windowed_mean(meal_cgm_master_list,row)
  windowed_average_list_meal.append(average_list)
windowed_average_list_df_meal = pd.DataFrame(windowed_average_list_meal)
windowed_average_list_df_meal

windowed_average_list_no_meal = []
for row in range (len(no_meal_cgm_master_list)):
  average_list = windowed_mean(no_meal_cgm_master_list,row)
  windowed_average_list_no_meal.append(average_list)
# print(windowed_average_list_no_meal)
windowed_average_list_df_no_meal = pd.DataFrame(windowed_average_list_no_meal)
windowed_average_list_df_meal

def calc_peaks_fouriertrans(meal_list,row):
    fouriertrans = list()
    peak_feat = list()
    arr = np.array(meal_list[row])
    # print(fft(arr))
    fouriertrans.append(abs(fft(arr)))
    for val in range(len(fouriertrans)):
      sets = set(fouriertrans[val])  
      set_list = list(sets)
      set_list.sort()
      set_list = set_list[::-1][0:8]
      # print(set_list)
      peak_feat+=set_list
    # print(peak_feat)
    return (fouriertrans,peak_feat)  


x_meal=[]
y_meal=[]
for row in range(len(meal_cgm_master_list)):
  x1,y1 = calc_peaks_fouriertrans(meal_cgm_master_list,row)
  x_meal.append(x1)
  y_meal.append(list(y1))
# print(len(y_meal))
peak_valdf_meal = pd.DataFrame(y_meal)
peak_valdf_meal

x_no_meal=[]
y_no_meal=[]
for row in range(len(no_meal_cgm_master_list)):
  x1,y1 = calc_peaks_fouriertrans(no_meal_cgm_master_list,row)
  x_no_meal.append(x1)
  y_no_meal.append(y1)
# print(y_no_meal)
peak_valdf_no_meal = pd.DataFrame(y_no_meal)
peak_valdf_no_meal

#def rank1(meal_cgm_master_list):
def calc_rank_row(meal_data,row):
  rank = [0 for x in range(len(meal_data[row]))]
  for j in range (len(meal_data[row])):
    (r,s)=(1,1)
    for k in range (len(meal_data[row])):
      if k != j and meal_data[row][k] < meal_data[row][j]:
        r += 1
      if k != j and meal_data[row][k] == meal_data[row][j]:
        s += 1       
    rank[j] = r + (s - 1) / 2
  return (rank) 

rank_list_meal=[]
for row in range(len(meal_cgm_master_list)):
    ranks_list_meal = calc_rank_row(meal_cgm_master_list,row)
    rank_list_meal.append(ranks_list_meal)

ranks_list_df_meal = pd.DataFrame(rank_list_meal)
ranks_list_df_meal = ranks_list_df_meal.iloc[:,:24]

rank_list_no_meal=[]
for row in range(len(no_meal_cgm_master_list)):
  ranks_list_no_meal = calc_rank_row(no_meal_cgm_master_list,row)
  rank_list_no_meal.append(ranks_list_no_meal)

ranks_list_df_no_meal = pd.DataFrame(rank_list_no_meal)
ranks_list_df_no_meal = ranks_list_df_no_meal.iloc[:,:24]

ranks_list_df_no_meal

def z_score_feat(meal_list,row):
  z_score_arr = np.array(meal_list[row])
  z_score_list = stats.zscore(z_score_arr)
  return (z_score_list)

z_scores_meal=[]
for row in range (len(meal_cgm_master_list)):
  z_score_res_list = z_score_feat(meal_cgm_master_list,row)
  z_scores_meal.append(z_score_res_list)
z_score_res_list_df_meal = pd.DataFrame(z_scores_meal)
z_score_res_list_df_meal = z_score_res_list_df_meal.iloc[:,:24]

z_scores_no_meal=[]
for row in range (len(no_meal_cgm_master_list)):
  z_score_res_list = z_score_feat(no_meal_cgm_master_list,row)
  z_scores_no_meal.append(z_score_res_list)
z_score_res_list_df_no_meal = pd.DataFrame(z_scores_no_meal)
z_score_res_list_df_no_meal = z_score_res_list_df_no_meal.iloc[:,:24]

z_score_res_list_df_no_meal

meal_data = pd.concat([difference_df_meal,coeff_of_var_df_meal,discrete_wavelet_df_meal,windowed_average_list_df_meal,peak_valdf_meal,ranks_list_df_meal,z_score_res_list_df_meal])
no_meal_data = pd.concat([difference_df_no_meal,coeff_of_var_df_no_meal,discrete_wavelet_df_no_meal,windowed_average_list_df_no_meal,peak_valdf_no_meal,ranks_list_df_no_meal,z_score_res_list_df_no_meal])
meal_data['Class_label']=1
no_meal_data['Class_label']=0

from sklearn.utils import shuffle
dataset = shuffle(pd.concat([meal_data,no_meal_data]).fillna(0)).reset_index().drop(columns = ['index'])
dataset1 = dataset.drop(columns = 'Class_label')
print(dataset1)

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from scipy import stats

feat_dataset = StandardScaler().fit_transform(dataset1)

pca = PCA(n_components= 15)
pca_component_extract = pca.fit_transform(feat_dataset)
pca_dataframe = pd.DataFrame(data = pca_component_extract, columns = ['PC 1', 'PC 2','PC 3','PC 4','PC 5','PC 6','PC 7','PC 8','PC 9','PC 10','PC 11','PC 12','PC 13','PC 14','PC 15'])

pca_dataframe['Class_label'] = dataset['Class_label']
pca_dataset = pca_dataframe.drop(columns = ['Class_label'])

def score_calc(model, x_train,x_test,y_train,y_test):
    model = model
    model.fit(x_train,y_train)
    #print(classification_report(y_train, y_test))
    return model.score(x_test,y_test)

scores_list = []
from sklearn.svm import SVC
from sklearn.model_selection import KFold
k_fold = KFold(n_splits=10)
for train_index, test_index in k_fold.split(pca_dataset):
    print("TRAIN:", train_index, "TEST:", test_index)
    
    x_train = pca_dataset.loc[train_index]
    x_test = pca_dataset.loc[test_index]
    y_train = pca_dataframe['Class_label'].loc[train_index]
    y_test = pca_dataframe['Class_label'].loc[test_index]
    pca_dataframe.Class_label.loc[train_index],pca_dataframe.Class_label.loc[test_index]
    
    scores = score_calc(SVC(), x_train, x_test, y_train, y_test)
    scores_list.append(scores)
    print(scores_list)

print(np.mean(scores_list))

from sklearn.svm import SVC
SVM_Classifier = SVC()
x_axis = pca_dataset 
y_axis = pca_dataframe['Class_label']
SVM_Classifier.fit(x_axis,y_axis)

predicted_labels = SVM_Classifier.predict(x_axis)

from sklearn.metrics import classification_report
print(classification_report(y_axis, predicted_labels))

# Using reference : https://scikit-learn.org/stable/modules/model_persistence.html
from joblib import dump, load
dump(SVM_Classifier, 'SVM_Classifier.pickle')